# forest_app/modules/narrative_modes.py

import logging
from typing import Optional, Dict, Any

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


class NarrativeModesEngine:
    """
    Determines the appropriate narrative mode and style directives for the Arbiter LLM
    based on the current system state and context (snapshot, threshold signals, etc.).

    This allows the Arbiter's output style to shift dynamically (e.g., become more
    direct, instructional, symbolic, or exceptionally gentle) when needed.
    """

    def __init__(self, config: Optional[Dict] = None):
        """
        Initializes the engine. Config defines different modes, their associated
        prompt directives, and potential triggers.
        """
        # Default configuration defining narrative modes and example triggers.
        # Consider loading this from an external JSON config file for flexibility.
        self.config = config or {
            "modes": {
                "default": {
                    "description": "Standard poetic, attuned System-Veil language.",
                    "style_directive": "Maintain the standard poetic, attuned, System-Veil language.",
                    "tone_override": None,  # Use tone derived from archetype/consequence
                },
                "instructional": {
                    "description": "Clear, step-by-step guidance.",
                    "style_directive": "Provide clear, numbered or step-by-step instructions where applicable for the task, while maintaining a supportive tone.",
                    "tone_override": "clear",
                },
                "symbolic_open": {
                    "description": "Emphasis on metaphor and open-ended questions.",
                    "style_directive": "Emphasize metaphor, symbolism, and open-ended questions. Use dreamlike, evocative language suitable for open exploration.",
                    "tone_override": "whimsical",  # Example override
                },
                "gentle_safety": {
                    "description": "Exceptionally gentle, reassuring, simple language.",
                    "style_directive": "Use exceptionally gentle, reassuring, and simple language. Prioritize safety, validation, and non-demand. Avoid complex metaphors or instructions.",
                    "tone_override": "gentle",
                },
                "direct_support": {
                    "description": "Direct and clear about support or action needed.",
                    "style_directive": "Be direct and clear about the support available or the action needed, while remaining compassionate and avoiding pressure. Focus on clarity and reassurance.",
                    "tone_override": "supportive",
                },
                "celebratory": {
                    "description": "Joyful, acknowledging progress or positive shifts.",
                    "style_directive": "Adopt a joyful, celebratory tone, acknowledging positive shifts or milestones achieved. Use uplifting language.",
                    "tone_override": "joyful",  # Example tone
                },
                # Add other modes as needed
            },
            # Define conditions that trigger specific modes. Logic is in determine_narrative_mode.
            # These keys should match keys potentially present in threshold_signals or derived context.
            "triggers": {
                "high_abuse": "gentle_safety",
                "urgent_repair_required": "direct_support",
                "low_capacity_high_shadow": "gentle_safety",
                "open_path": "symbolic_open",
                "task_requires_steps": "instructional",  # Needs context signal
                "high_consequence": "direct_support",
                "major_milestone_reached": "celebratory",  # Needs context signal (e.g., from XP system)
            },
            # Define thresholds used in trigger logic
            "thresholds": {
                "low_capacity": 0.2,
                "high_shadow": 0.8,
                "high_consequence": 0.8,  # Example threshold for practical consequence score
            },
        }
        logger.info("NarrativeModesEngine initialized.")

    def determine_narrative_mode(
        self, snapshot_dict: Dict[str, Any], context: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """
        Analyzes the snapshot and context to determine the appropriate narrative mode.

        Args:
            snapshot_dict: The dictionary representation of the MemorySnapshot.
            context: Optional dictionary containing additional context, like:
                     'threshold_signals': Dict from MetricsSpecificEngine.check_thresholds()
                     'base_task': Dict representing the task generated by TaskEngine
                     'detected_patterns': Dict from PatternIdentificationEngine

        Returns:
            A dictionary containing the selected mode details:
            {
                "mode": "selected_mode_name",
                "style_directive": "Specific instruction for the LLM style.",
                "tone_override": "optional_tone_keyword" # e.g., 'gentle', 'clear', None
            }
            Returns details for the "default" mode if no specific triggers are met.
        """
        context = context or {}
        threshold_signals = context.get("threshold_signals", {})
        base_task = context.get("base_task", {})  # Get base task for context
        # detected_patterns = context.get("detected_patterns", {}) # Example: use patterns later

        selected_mode_name = "default"  # Start with default
        trigger_config = self.config.get("triggers", {})
        threshold_values = self.config.get("thresholds", {})

        logger.debug("Determining narrative mode. Thresholds: %s", threshold_signals)

        # --- Trigger Logic (Prioritize more critical modes) ---
        # Refine this order and logic based on desired system behavior.

        # 1. Critical Safety/Support Triggers (from Metrics Thresholds)
        if threshold_signals.get("high_abuse"):
            selected_mode_name = trigger_config.get("high_abuse", "gentle_safety")
            logger.debug(
                "Triggered mode '%s' due to high_abuse signal.", selected_mode_name
            )
        elif threshold_signals.get("urgent_repair_required"):
            selected_mode_name = trigger_config.get(
                "urgent_repair_required", "direct_support"
            )
            logger.debug(
                "Triggered mode '%s' due to urgent_repair_required signal.",
                selected_mode_name,
            )
        # Check combined low capacity and high shadow
        elif snapshot_dict.get("capacity", 0.5) < threshold_values.get(
            "low_capacity", 0.2
        ) and snapshot_dict.get("shadow_score", 0.5) > threshold_values.get(
            "high_shadow", 0.8
        ):
            selected_mode_name = trigger_config.get(
                "low_capacity_high_shadow", "gentle_safety"
            )
            logger.debug(
                "Triggered mode '%s' due to low capacity and high shadow.",
                selected_mode_name,
            )

        # 2. Path-Based Triggers (If no critical trigger met)
        elif snapshot_dict.get("current_path") == "open":
            selected_mode_name = trigger_config.get("open_path", "symbolic_open")
            logger.debug("Triggered mode '%s' due to open path.", selected_mode_name)

        # 3. Task-Based Triggers (Example)
        # Check if the task itself suggests an instructional mode
        # This requires the TaskEngine or Orchestrator to add such a flag
        elif base_task.get(
            "needs_instructional_mode", False
        ):  # Check for a flag on the task
            selected_mode_name = trigger_config.get(
                "task_requires_steps", "instructional"
            )
            logger.debug("Triggered mode '%s' due to task flag.", selected_mode_name)

        # 4. Consequence-Based Triggers
        # Assuming practical consequence score is available (e.g., stored in snapshot state)
        # practical_consequence_score = snapshot_dict.get("component_state", {}).get("practical_consequence", {}).get("score", 0.5)
        # if practical_consequence_score > threshold_values.get("high_consequence", 0.8):
        #      selected_mode_name = trigger_config.get("high_consequence", "direct_support")
        #      logger.debug("Triggered mode '%s' due to high practical consequence.", selected_mode_name)

        # 5. Milestone/Celebration Triggers (Example)
        # milestone_reached = context.get("milestone_reached", False) # Orchestrator needs to provide this
        # if milestone_reached:
        #      selected_mode_name = trigger_config.get("major_milestone_reached", "celebratory")
        #      logger.debug("Triggered mode '%s' due to milestone reached.", selected_mode_name)

        # --- Get mode details from config ---
        modes_config = self.config.get("modes", {})
        # Fallback to default mode details if selected mode or default is missing
        default_mode_details = modes_config.get(
            "default",
            {
                "style_directive": "Use standard System-Veil language.",
                "tone_override": None,
            },
        )
        mode_details = modes_config.get(selected_mode_name, default_mode_details)

        # Construct the final result, ensuring keys always exist
        final_mode_output = {
            "mode": selected_mode_name,
            "style_directive": mode_details.get(
                "style_directive", default_mode_details["style_directive"]
            ),
            "tone_override": mode_details.get("tone_override"),  # This can be None
        }

        logger.info(
            "Determined narrative mode: %s -> Details: %s",
            selected_mode_name,
            final_mode_output,
        )
        return final_mode_output

    def to_dict(self) -> dict:
        """Serializes the engine's configuration."""
        # Currently only config is state, could add dynamic state later if needed
        return {"config": self.config}

    def update_from_dict(self, data: dict):
        """Updates the engine's configuration from a dictionary."""
        if "config" in data:
            config_update = data.get("config", {})
            if isinstance(config_update, dict):
                # Simple update; for deep merge, use a utility function if config gets complex
                self.config.update(config_update)
            else:
                logger.warning(
                    "Invalid format for config update in NarrativeModesEngine."
                )
        logger.debug("NarrativeModesEngine config updated from dict.")
